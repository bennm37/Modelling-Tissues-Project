import numpy as np
from numpy.lib.function_base import select 
import numpy.linalg as lag
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.patches import Polygon,Ellipse
import pandas as pd
import os  

def short_scale_repulsion(pvec,R=0.1,k=1):
    ##uses repulsion force k(2*R-r_ij) from active colloid paper
    dist = lag.norm(pvec,axis=2)
    f_ij = np.where(dist<R,-k*(np.full(dist.shape,2*R)-dist),np.zeros(dist.shape))
    return f_ij

def repulsion_cohesion_potential(pvec,R=1,k=1,epsilon=0.15):
    """Uses potential from the glassy behaviour paper[1], setting b_i =1 """
    dist = lag.norm(pvec,axis=2)
    f_ij = np.where(dist<R+R*epsilon,k*(R*dist-np.full(dist.shape,R**2)),np.zeros(dist.shape))
    ##TODO convoluted way of saying r<d<r_2 to get into one condition for where
    f_ij = np.where(np.abs(dist-(R+3*R*epsilon/2))<(R*epsilon/2),-k*(R*dist-np.full(dist.shape,(1+2*epsilon)*R**2)),f_ij)
    return f_ij

def repulsion_cohesion_potential2(pvec,R=1,k=1,epsilon=0.15,delta=0.2):
    """Uses potential from the glassy behaviour paper[1], setting b_i =1 """
    dist = lag.norm(pvec,axis=2)
    f_ij = np.where(dist<R+R*epsilon,k*(R*dist-np.full(dist.shape,R**2)),np.zeros(dist.shape))
    ##TODO convoluted way of saying r<d<r_2 to get into one condition for where
    f_ij = np.where(np.abs(dist-(R+3*R*epsilon/2))<(R*epsilon/2),-k*(R*dist-np.full(dist.shape,(1+2*epsilon)*R**2)),f_ij)
    return f_ij

class ABP(object):
    ##TODO add **kwargs ? 
    def __init__(self,parameters,potential):
        "N,v_0=0.1,box_width=10,dim=2,D=0.5,R=1,k=1,potential=short_scale_repulsion"
        """Creates N Active Brownian Particles with uniformly random
        initial positions and directions unless specified. V_0 is the 
        velocity generated by the traction of the crawling particle on 
        the substrate, measured relative to boxwidth, D is the 
        angular diffusivity parameter measured in radians, R is the 
        radius of particles measured in fraction of box width, k is
        the interaction strength (parameter of interaction force)."""
        #TODO protect against bad input
        self.dim = 2
        self.R = 1
        self.parameters = parameters
        self.v_0 = parameters["v_0"]
        self.N = parameters["N"]
        self.k = parameters["k"]
        self.D = parameters["D"] #diffusion of polarity
        self.box_width = parameters["box_width"]
        self.psi = potential
        self.r = np.random.uniform(0,self.box_width,(self.N,self.dim)) 
        self.thetas = np.random.uniform(0,2*np.pi,self.N)
        self.rdot = self.v_0*self.directions()+np.sum(self.interaction_forces(),axis=1)

    def update(self,dt):
        self.rdot = self.v_0*self.directions()+np.sum(self.interaction_forces(),axis=1)
        theta_dot = np.random.normal(0,self.D,self.thetas.shape) 
        self.r = (self.r + self.rdot*dt)%self.box_width #implements periodic boundary conditions
        self.thetas = self.thetas + np.sqrt(dt)*theta_dot
    
    def normalise_3darr(self,arr):
        normalised_arr = np.nan_to_num(arr/np.moveaxis(np.tile(lag.norm(arr,axis=2),(2,1,1)),0,2))
        return normalised_arr

    def pvec(self):
        """Returns a square matrix of pairwise vectors between all particles """
        r = self.r
        r_tile_v = np.tile(r,(self.N,1)).reshape(self.N,self.N,2)
        r_tile_h = np.tile(r,(1,self.N)).reshape(self.N,self.N,2)
        return r_tile_v-r_tile_h

    def wrapped_pvec(self):
        """Returns a square matrix of pairwise vectors between all particles 
        with periodic bounday conditions"""
        L = self.box_width
        pvec = self.pvec()
        # if the distance between particles is more than half the width of the
        # box then the distance is measured the other way
        return pvec - np.where(np.abs(pvec)>L,np.sign(pvec)*L,np.zeros(pvec.shape))
    
    def directions(self):
        return np.array([np.cos(self.thetas),np.sin(self.thetas)]).T
    
    def interaction_forces(self):
        """Uses psi to calculate f_ij, the magnitude of the force between each particle.
        Then multiplies f_ij by the normalised and wrapped vector between 2 particles."""
        pvec = self.wrapped_pvec()
        f_ij = self.psi(pvec,R = self.R,k=self.k)
        pvec_normalised = self.normalise_3darr(pvec)
        # print(pvec_normalised)
        forces = np.zeros(pvec.shape)
        forces[:,:,0] = f_ij*pvec_normalised[:,:,0]
        forces[:,:,1] = f_ij*pvec_normalised[:,:,1]
        return forces
    
    def generate_movement_data(self,T,dt,sample_rate):
        """Generates position and direction data for T time steps of length dt"""
        ##TODO do we need t_data?
        #t_data = np.linspace(0,T,int(T//dt))
        num_samples = np.floor(T//sample_rate)
        r_data = np.zeros((num_samples,self.N,self.dim))
        direction_data = np.zeros((num_samples,self.N,self.dim))
        velocity_data = np.zeros((num_samples,self.N,self.dim))
        r_data[0,:,:] = self.r
        direction_data[0,:,:] = self.directions()
        velocity_data[0,:,:] = self.rdot
        for i in range(1,num_samples):
            for j in range(sample_rate):
                self.update(dt)
            r_data[i,:,:] = self.r
            direction_data[i,:,:] = self.directions()
            velocity_data[i,:,:] = self.rdot
        return r_data,direction_data,velocity_data

    def get_parameter_suffix(self):
        """Generates a parameter suffix for csv naming"""
        p_dict = self.parameters
        out = "__".join([key+"_"+str(p_dict[key]) for key in p_dict])
        return out

    def generate_csv(self,T,dt,sample_rate,folder_name = None):
        """Makes a folder named after parameter values 
        and saves the positions velocities and directions 
        at each sample rate dts"""
        if folder_name:
            folder_name = folder_name
        else:
            folder_name = "abp_data__"+self.get_parameter_suffix()
        os.mkdir(f"./data/{folder_name}")
        num_samples = int(np.floor(T//sample_rate))
        columns = ["x1","x2","d1","d2","v1","v2"]
        data = np.append(self.r,self.directions(),axis=1)
        data = np.append(data,self.rdot,axis=1)
        data_frame = pd.DataFrame(data,columns=columns)
        data_frame.to_csv(f"./data/{folder_name}/data_0.csv")
        for i in range(1,num_samples):
            for j in range(sample_rate):
                self.update(dt)
            data = np.append(self.r,self.directions(),axis=1)
            data = np.append(data,self.rdot,axis=1)
            data_frame = pd.DataFrame(data,columns=columns)
            data_frame.to_csv(f"./data/{folder_name}/data_{i}.csv")
        return folder_name

class Analysis(object):
    def __init__(self,data_name,parameters,T,dt,n_saves,data_type ="ben"):
        self.T = T
        self.dt = dt
        self.n_saves = n_saves
        self.N = parameters["N"]
        self.p_dict = parameters

        if data_type == "ben":
            filenames = [f"dat_{i}" for i in range(self.n_saves)]
            frames = [pd.read_csv(f"{data_name}/{filename}.csv") for filename in filenames]
            df = pd.concat(frames)
            self.r_data = np.array(df[["x1","x2"]]).reshape(self.n_saves,self.N,2)
            self.v_data = np.array(df[["v1","v2"]]).reshape(self.n_saves,self.N,2)
            self.d_data = np.array(df[["d1","d2"]]).reshape(self.n_saves,self.N,2)
        
        if data_type == "pyABP":
            dat_content = [i.strip().split() for i in open(f"{data_name}/data1.dat")]
            columns = dat_content[0]
            data = np.zeros((self.n_saves,self.N,8))
            for i in range(0,self.n_saves):
                dat_i = [i.strip().split() for i in open(f"{data_name}/data{i}.dat")]
                data[i,:,:] = dat_i[1:]
            df = pd.DataFrame(data.reshape(self.N*self.n_saves,8),columns=columns)
            self.r_data = np.array(df[["x1","x2"]]).reshape(self.n_saves,self.N,2)
            self.v_data = np.array(df[["v1","v2"]]).reshape(self.n_saves,self.N,2)
            self.theta_data = np.array(df["theta"]).reshape(self.n_saves,self.N,1)
            self.d_data = np.append(np.cos(self.theta_data),np.sin(self.theta_data),axis = 2)

    def analytic_msd(self,num_time_steps):
        tau_r =1 #what is persistence time?
        interval = num_time_steps*self.pm["dt"]
        4*self.p_dict["D"]+2*self.p_dict["v_0"]**2*tau_r*(interval-tau_r*(1-np.exp(-interval/tau_r)))
    
    def msd(self,m):
        i_sum = np.sum((self.r_data[m:,:]-self.r_data[:self.T-m,:])**2,axis=1)
        msd = np.sum(i_sum)/(self.T-m)
        return msd
    
    def generate_msd_data(self):
        m_range = np.linspace(0,self.T,self.T,dtype=int)
        msd_data = np.zeros(m_range.shape)
        for i,m in enumerate(m_range):
            if self.msd(m)==np.nan:
                print(m)
            msd_data[i] = self.msd(m)
        return msd_data

    def plot_frame(self,frame_no):
        asp = [10,10,15]
        r_data,direction_data,velocity_data = self.r_data,self.d_data,self.v_data
        fig,ax = plt.subplots()
        fig.set_size_inches(8,8)
        ax.set(xlim=(0,self.p_dict["box_width"]),ylim=(0,self.p_dict["box_width"]))
        directions = ax.quiver(r_data[frame_no,:,0],r_data[frame_no,:,1],direction_data[frame_no,:,0],direction_data[0,:,1],
            headaxislength=asp[0],headlength=asp[1],scale=asp[2])
        velocities = ax.quiver(r_data[frame_no,:,0],r_data[frame_no,:,1],velocity_data[frame_no,:,0],velocity_data[0,:,1],color="r",
            headaxislength=asp[0],headlength=asp[1],scale=asp[2])
        for cell in r_data[frame_no,:,:]:
            c = Ellipse(cell,1,1,fill=False,color="k")
            p = ax.add_patch(c)

    def animate_movement_patch(self,sample_rate =10,patch_type="circle"):
        """Animates the movement of the active brownian particles using a 
        matplotlib quiver plot"""
        ##TODO sort arrow scaling
        asp = [10,10,15] ##arrow shape parameters
        r_data,direction_data,velocity_data = self.r_data,self.d_data,self.v_data
        fig,ax = plt.subplots()
        fig.set_size_inches(8,8)
        ax.set(xlim=(0,self.p_dict["box_width"]),ylim=(0,self.p_dict["box_width"]))
        directions = ax.quiver(r_data[0,:,0],r_data[0,:,1],direction_data[0,:,0],direction_data[0,:,1],
            headaxislength=asp[0],headlength=asp[1],scale=asp[2])
        velocities = ax.quiver(r_data[0,:,0],r_data[0,:,1],velocity_data[0,:,0],velocity_data[0,:,1],color="r",
            headaxislength=asp[0],headlength=asp[1],scale=asp[2])
        ##This creates circles with diameter 1, not radius 1
        for cell in r_data[0,:,:]:
            c = Ellipse(cell,1,1,fill=False,color="k")
            p = ax.add_patch(c)
        def update_anim(i):
            sample = i*sample_rate
            ax.clear()
            ax.set(title=f"frame no {i}")
            ax.set(xlim=(0,self.p_dict["box_width"]),ylim=(0,self.p_dict["box_width"]))
            directions = ax.quiver(r_data[sample,:,0],r_data[sample,:,1],direction_data[sample,:,0],direction_data[sample,:,1],
                headaxislength=asp[0],headlength=asp[1],scale=asp[2])
            velocities = ax.quiver(r_data[sample,:,0],r_data[sample,:,1],velocity_data[sample,:,0],velocity_data[sample,:,1],color="r",
                headaxislength=asp[0],headlength=asp[1],scale=asp[2])
            for cell in r_data[sample,:,:]:
                c = Ellipse(cell,1,1,fill=False,color="k")
                p = ax.add_patch(c)
        anim = animation.FuncAnimation(fig,update_anim,frames=self.n_saves//sample_rate)
        return anim
        